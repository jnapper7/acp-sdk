# generated by datamodel-codegen:
#   filename:  openapi.yaml

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import AnyUrl, AwareDatetime, BaseModel, Field, RootModel, conint
from typing_extensions import Literal


class AgentManifestRef(BaseModel):
    name: str = Field(
        ...,
        description='Name of the agent that identifies the agent in its manifest',
        title='Name',
    )
    version: str = Field(
        ...,
        description='Version of the agent in its manifest. Should be formatted according to semantic versioning (https://semver.org)',
        title='Version',
    )
    url: Optional[AnyUrl] = Field(
        None,
        description='URL of the manifest. Can be a network location or a file.',
        title='Manifest URL',
    )


class Capabilities(BaseModel):
    threads: Optional[bool] = Field(
        False,
        description='this is True if the agent supports run threads. If this is False, then the threads tagged with `Threads` are not available. If missing, it means `false`',
        title='Thread Support',
    )
    interrupts: Optional[bool] = Field(
        False,
        description='this is True if the agent runs can interrupt to request additional input and can be subsequently resumed. If missing, it means `false`',
        title='Interrupt Support',
    )
    callbacks: Optional[bool] = Field(
        False,
        description='this it True if the agent supports a webhook to report run results. If this is false, providing a `webhook` at run creation has no effect. If missing, it means `false`',
        title='Callback Support',
    )


class Interrupt(BaseModel):
    interrupt_type: str = Field(
        ...,
        description='Name of this interrupt type. Needs to be unique in the list of interrupts.',
        title='Interrupt Type Name',
    )
    interrupt_payload: Optional[Dict[str, Any]] = Field(
        None,
        description='This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object',
        examples=[
            {
                'type': 'object',
                'required': ['name'],
                'properties': {
                    'name': {'type': 'string'},
                    'address': {'type': 'string'},
                    'age': {'type': 'integer', 'format': 'int32', 'minimum': 0},
                },
            }
        ],
    )
    resume_payload: Dict[str, Any] = Field(
        ...,
        description='This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object',
        examples=[
            {
                'type': 'object',
                'required': ['name'],
                'properties': {
                    'name': {'type': 'string'},
                    'address': {'type': 'string'},
                    'age': {'type': 'integer', 'format': 'int32', 'minimum': 0},
                },
            }
        ],
    )


class Specs(BaseModel):
    capabilities: Capabilities = Field(
        ...,
        description='Declares what invocation features this agent is capable of.',
        title='Agent Capabilities',
    )
    input: Dict[str, Any] = Field(
        ...,
        description='This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object',
        examples=[
            {
                'type': 'object',
                'required': ['name'],
                'properties': {
                    'name': {'type': 'string'},
                    'address': {'type': 'string'},
                    'age': {'type': 'integer', 'format': 'int32', 'minimum': 0},
                },
            }
        ],
    )
    output: Dict[str, Any] = Field(
        ...,
        description='This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object',
        examples=[
            {
                'type': 'object',
                'required': ['name'],
                'properties': {
                    'name': {'type': 'string'},
                    'address': {'type': 'string'},
                    'age': {'type': 'integer', 'format': 'int32', 'minimum': 0},
                },
            }
        ],
    )
    thread_state: Optional[Dict[str, Any]] = Field(
        None,
        description='This describes the format of ThreadState.  Cannot be specified if `threads` capability is false. If not specified, when `threads` capability is true, then the API to retrieve ThreadState from a Thread or a Run is not available. This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object',
        examples=[
            {
                'type': 'object',
                'required': ['name'],
                'properties': {
                    'name': {'type': 'string'},
                    'address': {'type': 'string'},
                    'age': {'type': 'integer', 'format': 'int32', 'minimum': 0},
                },
            }
        ],
    )
    config: Dict[str, Any] = Field(
        ...,
        description='This object contains an instance of an OpenAPI schema object, formatted as per the OpenAPI specs: https://spec.openapis.org/oas/v3.1.1.html#schema-object',
        examples=[
            {
                'type': 'object',
                'required': ['name'],
                'properties': {
                    'name': {'type': 'string'},
                    'address': {'type': 'string'},
                    'age': {'type': 'integer', 'format': 'int32', 'minimum': 0},
                },
            }
        ],
    )
    interrupts: Optional[List[Interrupt]] = Field(
        None,
        description='List of possible interrupts that can be provided by the agent. If `interrupts` capability is true, this needs to have at least one item.',
    )


class Type(Enum):
    source_code = 'source_code'


class FrameworkType(Enum):
    langgraph = 'langgraph'


class LangGraphConfig(BaseModel):
    framework_type: Literal['langgraph']
    graph: str


class FrameworkType1(Enum):
    llamaindex = 'llamaindex'


class LlamaIndexConfig(BaseModel):
    framework_type: Literal['llamaindex']
    path: str


class Type1(Enum):
    remote_service = 'remote_service'


class Type2(Enum):
    docker = 'docker'


class Type3(Enum):
    ACP = 'ACP'


class SecurityScheme(BaseModel):
    pass


class AgentSearchRequest(BaseModel):
    name: Optional[str] = Field(
        None, description='Match all agents with the name specified.', title='Name'
    )
    version: Optional[str] = Field(
        None,
        description='Match all agents with the version specified. Formatted according to semantic versioning (https://semver.org)',
        title='Version',
    )
    limit: Optional[conint(ge=1, le=1000)] = Field(
        10, description='Maximum number to return.', title='Limit'
    )
    offset: Optional[conint(ge=0)] = Field(
        0, description='Offset to start from.', title='Offset'
    )


class ErrorResponse(RootModel[str]):
    root: str = Field(
        ..., description='Error message returned from the server', title='ErrorResponse'
    )


class Status(Enum):
    pending = 'pending'
    error = 'error'
    success = 'success'
    timeout = 'timeout'
    interrupted = 'interrupted'


class RunSearchRequest(BaseModel):
    agent_id: Optional[UUID] = Field(
        None,
        description='Matches all the Runs associated with the specified Agent ID.',
        title='Agent Id',
    )
    status: Optional[Status] = Field(
        None,
        description="Matches all the Runs associated with the specified status. One of 'pending', 'error', 'success', 'timeout', 'interrupted'.",
        title='Status',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Matches all threads for which metadata has  keys and values equal to those specified in this object.',
        title='Metadata Filter',
    )
    limit: Optional[conint(ge=1, le=1000)] = Field(
        10, description='Maximum number to return.', title='Limit'
    )
    offset: Optional[conint(ge=0)] = Field(
        0, description='Offset to start from.', title='Offset'
    )


class Type4(Enum):
    result = 'result'


class Type5(Enum):
    error = 'error'


class RunError(BaseModel):
    type: Literal['error'] = Field(..., title='Output Type')
    run_id: Optional[UUID] = Field(
        None, description='The ID of the run.', title='Run Id'
    )
    errcode: Optional[int] = Field(
        None, description='code of the error', title='Error Code'
    )
    description: Optional[str] = Field(
        None, description='description of the error', title='Error Description'
    )


class Type6(Enum):
    interrupt = 'interrupt'


class InputSchema(BaseModel):
    pass


class OutputSchema(BaseModel):
    pass


class ConfigSchema(BaseModel):
    pass


class ThreadStateSchema(BaseModel):
    pass


class InterruptPayloadSchema(BaseModel):
    pass


class ResumePayloadSchema(BaseModel):
    pass


class ThreadCreate(BaseModel):
    agent_id: Optional[str] = Field(
        None,
        description='Identifier of the agent this thread is executed on',
        title='Agent ID',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Free form metadata for this thread', title='Metadata'
    )


class ThreadSearchRequest(BaseModel):
    agent_id: Optional[UUID] = Field(
        None,
        description='Matches all threads associated with the specified agent ID.',
        title='Agent Id',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Matches all threads for which metadata has  keys and values equal to those specified in this object.',
        title='Metadata Filter',
    )
    limit: Optional[conint(ge=1, le=1000)] = Field(
        10, description='Maximum number to return.', title='Limit'
    )
    offset: Optional[conint(ge=0)] = Field(
        0, description='Offset to start from.', title='Offset'
    )


class Thread(BaseModel):
    thread_id: Optional[str] = Field(
        None, description='unique identifier of a thread', title='Thread ID'
    )
    agent_id: Optional[str] = Field(
        None,
        description='Identifier of the agent this thread is executed on',
        title='Agent ID',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None, description='Free form metadata for this thread', title='Metadata'
    )


class AgentMetadata(BaseModel):
    ref: AgentManifestRef
    description: str = Field(
        ...,
        description='Description of this agent, which should include what the intended use is, what tasks it accomplishes and how uses input and configs to produce the output and any other side effect',
        title='Description',
    )


class SourceCodeDeployment(BaseModel):
    type: Literal['source_code']
    name: Optional[str] = Field(
        None,
        description='Name this deployment option is referred to within this agent. This is needed to indicate which one is preferred when this manifest is referred. Can be omitted, in such case selection is not possible.',
        title='Deployment Option Name',
    )
    url: AnyUrl = Field(
        ...,
        description='Location of the source code. E.g. path to code root, github repo url etc.',
        title='Source Code Locator',
    )
    framework_config: Union[LangGraphConfig, LlamaIndexConfig] = Field(
        ..., discriminator='framework_type'
    )


class AgentConnectProtocol(BaseModel):
    type: Type3
    url: AnyUrl = Field(
        ..., description='URL pointing to the ACP endpoint root.', title='ACP URL'
    )
    agent_id: Optional[UUID] = Field(
        None,
        description='Agent identifier in ACP server. If missing, the first returned agent with matching name and version should be used.',
        title='Agent identifier',
    )
    authentication: Optional[SecurityScheme] = None


class RunCreate(BaseModel):
    agent_id: UUID = Field(..., description='The ID of the agent.', title='Agent Id')
    thread_id: Optional[UUID] = Field(
        None,
        description='Optional Thread ID wher the Run belongs to. This can be used only for agents supporting Threads.',
        title='Agent ID',
    )
    input: Optional[InputSchema] = None
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Metadata to assign to the run. Optional free format metadata to attach to the run.',
        title='Metadata',
    )
    config: Optional[ConfigSchema] = None
    webhook: Optional[AnyUrl] = Field(
        None,
        description='Webhook to call after run finishes or interrupts. If missing no callback is called and the client needs to poll.',
        title='Completion or Interrupt webhook',
    )


class Run(BaseModel):
    creation: Optional[RunCreate] = None
    run_id: Optional[UUID] = Field(
        None, description='The ID of the run.', title='Run Id'
    )
    agent_id: Optional[UUID] = Field(
        None, description='The agent that was used for this run.', title='Agent Id'
    )
    thread_id: Optional[UUID] = Field(
        None,
        description='Optional Thread ID wher the Run belongs to. This is populated only for runs on agents agents supporting Threads.',
        title='Agent ID',
    )
    created_at: Optional[AwareDatetime] = Field(
        None, description='The time the run was created.', title='Created At'
    )
    updated_at: Optional[AwareDatetime] = Field(
        None, description='The last time the run was updated.', title='Updated At'
    )
    status: Optional[Status] = Field(
        None,
        description="The status of the run. One of 'pending', 'error', 'success', 'timeout', 'interrupted'.",
        title='Status',
    )


class RunResult(BaseModel):
    type: Literal['result'] = Field(..., title='Output Type')
    run_id: Optional[UUID] = Field(
        None, description='The ID of the run.', title='Run Id'
    )
    result: Optional[OutputSchema] = None


class RunInterrupt(BaseModel):
    type: Literal['interrupt'] = Field(..., title='Output Type')
    interrupt: Optional[InterruptPayloadSchema] = None


class Agent(BaseModel):
    agent_id: UUID = Field(
        ...,
        description='Unique identifier of the agent in this server.',
        title='Agent Id',
    )
    metadata: AgentMetadata


class RemoteServiceDeployment(BaseModel):
    type: Literal['remote_service']
    protocol: AgentConnectProtocol


class DockerDeployment(BaseModel):
    type: Literal['docker']
    image: AnyUrl = Field(
        ..., description='Container image for the agent', title='Agent Docker image'
    )
    protocol: AgentConnectProtocol


class RunOutput(RootModel[Union[RunResult, RunInterrupt, RunError]]):
    root: Union[RunResult, RunInterrupt, RunError] = Field(
        ...,
        description='Output of a Run. Can be the final result or an interrupt.',
        discriminator='type',
        title='Run Output',
    )


class Deployments(
    RootModel[Union[SourceCodeDeployment, RemoteServiceDeployment, DockerDeployment]]
):
    root: Union[SourceCodeDeployment, RemoteServiceDeployment, DockerDeployment] = (
        Field(..., discriminator='type')
    )


class AgentManifest(BaseModel):
    metadata: AgentMetadata
    specs: Specs = Field(
        ...,
        description='Specification of agent capabilities, config, input, output, and interrupts',
        title='Agent Specs',
    )
    dependencies: Optional[List[AgentManifestRef]] = Field(
        None,
        description='List of all other agents this agent depends on',
        title='Agent Dependencies',
    )
    deployments: Optional[List[Deployments]] = Field(
        None,
        description='List of possible methods to instantiate or consume the agent.  Any of the available option could be used.\nEvery option could be associated with a unique name within this agent. If present, when another manifest refers to this manifest, it can also select the preferred deployment option.',
        title='Deployment Options',
    )
